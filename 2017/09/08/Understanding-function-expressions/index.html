<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>了解函数表达式 - Manzeon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="定义函数有两种方式：函数声明和函数表达式，其中函数声明，有一个重要的特性就是函数声明提升，就是在执行代码之前会首先读取函数声明。这也是理解函数声明和函数表达式之间区别的关键。">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="了解函数表达式">
<meta property="og:url" content="http://www.gongwenjun.com/2017/09/08/Understanding-function-expressions/index.html">
<meta property="og:site_name" content="Manzeon">
<meta property="og:description" content="定义函数有两种方式：函数声明和函数表达式，其中函数声明，有一个重要的特性就是函数声明提升，就是在执行代码之前会首先读取函数声明。这也是理解函数声明和函数表达式之间区别的关键。">
<meta property="og:updated_time" content="2017-09-08T14:54:58.683Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="了解函数表达式">
<meta name="twitter:description" content="定义函数有两种方式：函数声明和函数表达式，其中函数声明，有一个重要的特性就是函数声明提升，就是在执行代码之前会首先读取函数声明。这也是理解函数声明和函数表达式之间区别的关键。">
  
  
    <link rel="icon" href="http://ota91wfkz.bkt.clouddn.com/favicon.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <img src="http://ota91wfkz.bkt.clouddn.com/favicon.jpg" alt="logo">
        <a href="/" id="logo">Manzeon</a>
      </h1>
      <ul class="social-links">
        
        <li><a href="https://github.com/Manzeon">github</a></li>
        
        <li><a href="mailto:gwj19950626@gmail.com">email</a></li>
        
        <li><a href="/atom.xml">rrs</a></li>
        
      </ul>
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <ul>
        
        <li><a class="main-nav-link" href="/">Home</a></li>
        
        <li><a class="main-nav-link" href="/archives">Archives</a></li>
        
        <li><a class="main-nav-link" href="/about">About</a></li>
        
        </ul>
      </nav>
    </div>
</header>
<header id="header-mobile">
  <a id="main-nav-toggle" class="nav-icon"></a>
  <img src="http://ota91wfkz.bkt.clouddn.com/favicon.jpg" alt="logo">
</header>
      <main id="main"><article id="post-Understanding-function-expressions" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      了解函数表达式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>定义函数有两种方式：函数声明和函数表达式，其中函数声明，有一个重要的特性就是<strong>函数声明提升</strong>，就是在执行代码之前会首先读取函数声明。这也是理解函数声明和函数表达式之间区别的关键。<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 函数声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1, arg2</span>)</span>&#123;</div><div class="line">  <span class="comment">//函数体</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 函数表达式</span></div><div class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>)</span>&#123;</div><div class="line">  <span class="comment">//函数体</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数就是在一个函数中通过名字调用自身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>arguments.callee</code>是一个指向正在执行的函数的指针，可用来实现递归调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> anotherFactorial = factorial;</div><div class="line">factorial = <span class="literal">null</span>;</div><div class="line">alert(anotherFactorial(<span class="number">4</span>));<span class="comment">// Uncaught TypeError: factorial is not a function</span></div><div class="line"></div><div class="line"><span class="comment">// 这种情况就可以用 arguments.callee 来解决，</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 但严格模式下不能访问 arguments.callee，访问这个属性会导致错误。</span></div><div class="line"><span class="comment">// 所以可以用命名函数表达式来达成相同的结果</span></div><div class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">num</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是指有权访问另一个函数作用域中变量的函数。创建闭包的常见方式就是在一个函数内部创建另一个函数，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj1, obj2</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> val1 = obj1[propertyName];</div><div class="line">    <span class="keyword">var</span> val2 = obj2[propertyName];</div><div class="line">      </div><div class="line">    <span class="keyword">if</span> (val1 &lt; val2) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val1 &gt; val2) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于闭包，在一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域链中。即当<code>createComparisonFunction()</code>函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中，知道匿名函数被销毁后（接触对匿名函数的引用）该活动对象才会被销毁。</p>
<p>校招笔试题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现template方法，用于解析模板，实现效果如下：</span></div><div class="line"><span class="keyword">var</span> compiled = template(<span class="string">'hello &lt;%= user %&gt;!'</span>);</div><div class="line">compiled(&#123;<span class="string">'user'</span>: <span class="string">'world'</span>&#125;);<span class="comment">// =&gt; 'hello world!'</span></div><div class="line"><span class="keyword">var</span> compiled = template(<span class="string">'welcome to &lt;%= location %&gt;!'</span>);</div><div class="line">compiled(&#123;<span class="string">'location'</span>: <span class="string">'Guangzhou'</span>&#125;);<span class="comment">// =&gt; 'welcome to Guangzhou!'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">template</span>(<span class="params">tem</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> tem.replace(<span class="regexp">/&lt;%=\s(\w+)\s%&gt;/</span>,<span class="function"><span class="keyword">function</span>(<span class="params">a, $<span class="number">1</span></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> obj[$<span class="number">1</span>];</div><div class="line">	&#125;);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">compiled = <span class="literal">null</span>;<span class="comment">// 内存释放</span></div></pre></td></tr></table></figure></p>
<h2 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h2><p>需要注意，闭包只能取得包含函数中任何变量的最后一个值。因为闭包保存的是整个变量对象，而不是某个特殊的变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> i;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">createFunctions()[<span class="number">2</span>]();<span class="comment">// =&gt; 10</span></div></pre></td></tr></table></figure></p>
<p>每个函数都返回10,因为每个函数的作用域链中都保存的是函数<code>createFunctions()</code> 的活动对象，所以引用的都是统一变量<code>i</code>，当<code>createFunctions()</code>返回时，变量i的值为10。通过创建一个匿名函数强制让闭包行为符合预期。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    result[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> num;</div><div class="line">      &#125;;</div><div class="line">    &#125;)(i);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">createFunctions()[<span class="number">2</span>]();<span class="comment">// =&gt; 2</span></div></pre></td></tr></table></figure></p>
<h2 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h2><p><code>this</code>对象是在运行时基于函数的执行环境绑定的，在全局函数中，<code>this</code>等于<code>window</code>，当函数作为某个对象的方法被调用时，<code>this</code>等于那个对象。但是，匿名函数的执行环境具有全局性，所以其<code>this</code>对象通常又指向<code>window</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"the window"</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">"my obj"</span>,</div><div class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.getNameFunc()();<span class="comment">//在非严格模式下 =&gt; "the window" ，严格模式下，匿名函数this指向undefined，所以会报错。</span></div></pre></td></tr></table></figure></p>
<p>把在外部作用域中的<code>this</code>对象保存在一个闭包能够访问到的变量，就可以让闭包访问该对象了。同样，<code>arguments</code>也会存在这样的问题，解决方法也一样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"the window"</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">"my obj"</span>,</div><div class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> that.name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.getNameFunc()();<span class="comment">// =&gt;"my obj"</span></div></pre></td></tr></table></figure></p>
<h2 id="模仿块作用域"><a href="#模仿块作用域" class="headerlink" title="模仿块作用域"></a>模仿块作用域</h2><p>匿名函数可以用来模仿块级作用域：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 这里是块级作用域</span></div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="comment">// 块级作用域</span></div><div class="line">&#125;();<span class="comment">//语法错误：JavaScript讲function关键字当做一个函数声明的开始，而函数声明后面不能跟圆括号。函数声明外加一对括号就可以转换成函数表达式。</span></div></pre></td></tr></table></figure></p>
<p><strong>ES6中新增<code>let</code>命令用于声明变量,所声明的变量，只在<code>let</code>命令所在的代码块内有效。</strong></p>
<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>严格来讲，JavaScript中没有私有成员的概念，所有对象属性都是公有的。但有私有变量的概念，任何函数中定义的变量，都可以认为是私有变量，包括函数的参数、局部变量和在函数内定义的其他函数。在函数内部创建一个闭包，那么闭包通过自己的作用域链就可以访问这些变量。而把有权访问私有变量和私有函数的公有方法称为特权方法。<br>有两种创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObj</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//私有变量和私有函数</span></div><div class="line">  <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//特权方法</span></div><div class="line">  <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    privateVariable++;</div><div class="line">    <span class="keyword">return</span> privateFunction();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    name = value;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>);</div><div class="line">person.getName();<span class="comment">//=&gt;"Nicholas"</span></div><div class="line">person.setName(<span class="string">'Greg'</span>);</div><div class="line">person.getName();<span class="comment">//=&gt;"Greg"</span></div></pre></td></tr></table></figure></p>
<p>私有变量<code>name</code>在<code>Person</code>的每一个实例中都不相同，因为每次调用构造函数都会重新创建这两个方法。而构造函数模式有一个缺点，针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。</p>
<h2 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h2><p>通过在私有作用域中定义私有变量或函数，同样可以创建特权方法，基本模式如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//私有变量和私有函数</span></div><div class="line">  <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//构造函数</span></div><div class="line">  MyObj = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//特权方法</span></div><div class="line">  MyObj.prototype.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    privateVariable++;</div><div class="line">    <span class="keyword">return</span> privateFunction();</div><div class="line">  &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>这个模式创建了一个私有作用域，并在其中封装了一个构造函数级相应的方法，特权方法是在原型上定义的，体现了典型的原型模式。但是，定义构造函数使用了函数表达式而不是函数声明，并且定义时没有使用<code>var</code>关键字，所以构造函数才会变成全局变量能够在私有作用域外被访问，然而，在严格模式下，给未经声明的变量赋值会导致错误。而且，在这种模式下，私有变量和函数是由实例共享的，即实例上调用公有方法会影响所有的实例。</p>
<h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><p>模块模式是为单例创建私有变量和特权方法的。语法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//私有变量和私有函数</span></div><div class="line">  <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//特权方法和属性</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    publicProperty: <span class="literal">true</span>,</div><div class="line">    publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      privateVariable++;</div><div class="line">      <span class="keyword">return</span> privateFunction();</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>这个模块模式使用了一个返回对象的匿名函数，其中定义了私有变量和函数，然后将一个对象字面量作为函数的返回值。返回的对象字面量中包含可以公开的属性和方法，此对象在匿名函数内部定义，因而它的公有方法有权访问私有变量和函数。</p>
<p>这种模式在需要对单例进行初始化，同时又需要维护其私有变量时，是非常有用的。如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> application = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//私有变量和函数</span></div><div class="line">  <span class="keyword">var</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  components.push(<span class="keyword">new</span> BaseComponent());</div><div class="line">  </div><div class="line">  <span class="comment">//公共</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    getComponentCount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> components.length;</div><div class="line">    &#125;,</div><div class="line">    registerComponent: <span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> component === <span class="string">"object"</span>) &#123;</div><div class="line">        components.push(component);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<h2 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h2><p>在模块模式基础上，在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况。如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//私有变量和函数</span></div><div class="line">  <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//创建对象</span></div><div class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> CustomType();</div><div class="line">  </div><div class="line">  <span class="comment">//添加特权属性和方法</span></div><div class="line">  obj.publicProperty = <span class="literal">true</span>;</div><div class="line">  obj.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    privateVariable++;</div><div class="line">    <span class="keyword">return</span> privateFunction();</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;();</div><div class="line"></div><div class="line"><span class="keyword">var</span> application = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//私有变量和函数</span></div><div class="line">  <span class="keyword">var</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  components.push(<span class="keyword">new</span> BaseComponent());</div><div class="line">  </div><div class="line">  <span class="comment">//创建局部副本</span></div><div class="line">  <span class="keyword">var</span> app = <span class="keyword">new</span> BaseComponent();</div><div class="line">  <span class="comment">//公共</span></div><div class="line">  app.getComponentCount = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> components.length;</div><div class="line">  &#125;;</div><div class="line">  app.registerComponent = <span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> component === <span class="string">"object"</span>) &#123;</div><div class="line">      components.push(component);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> app;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《JavaScript高级程序设计（第三版）》</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <p class="article-date">
  <time datetime="2017-09-08T14:50:00.000Z" itemprop="datePublished">2017-09-08</time>
</p>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/09/06/Box-Model/" id="articleOlder" class="btn">下一篇</a>
  
</nav>

  
</article>



</main>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Manzeon<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/script.js"></script>

  </div>
</body>
</html>